Програм хангамжийн зохиомж нь програм хангамжийн системийн бүтэц, түүний бүрэлдэхүүн хэсгүүдийн харилцан үйлчлэл, зан төлөвийг тодорхойлох үйл явц юм. Энэ нь програм хангам- жийн хөгжүүлэлтийн амжилтын гол хүчин зүйл бөгөөд системийн чанар, уян хатан байдал, засвар үйлчилгээний чадамжид шууд нөлөөлдөг. Зохиомж нь системийн шаардлага, бизнес- ийн зорилго, техникийн хязгаарлалтыг ойлгох, эдгээрийг зохицуулсан шийдэл гаргахыг шаард- даг.
\section{Програм хангамжийн зохиомжийн зарчмууд}
Програм хангамжийн зохиомжийн зарчмууд нь сайн зохиомжийг бий болгоход чиглэсэн удирдамж, хамгийн сайн туршлагуудын цуглуулга юм. Эдгээр зарчмууд нь програм хангам- жийн системийг уян хатан, дахин ашиглах боломжтой, засвар үйлчилгээ хийхэд хялбар болго- ход тусалдаг. SOLID зарчмуудыг доор дурдлаа:
\begin{itemize}
	\item \textbf{Single Responsibility Principle}: Класс эсвэл модуль нь зөвхөн нэг л шалтгаанаар өөрчлөг- дөх ёстой. Энэ нь кодыг илүү ойлгомжтой, засвар үйлчилгээ хийхэд хялбар болгодог.
	\item \textbf{Open/Closed Principle}: Програм хангамжийн элементүүд нь өргөтгөхөд нээлттэй, өөрч- лөхөд хаалттай байх ёстой. Энэ нь шинэ функц нэмэхдээ одоо байгаа кодыг өөрчлөхгүй байхыг шаарддаг.
	\item \textbf{Liskov Substitution Principle}: Суперклассын объектуудыг түүний дэд классын объек- туудаар орлуулах боломжтой байх ёстой. Энэ нь полиморфизмын үндсэн зарчим бөгөөд кодыг илүү уян хатан болгодог.
	% \begin{itemize}
	% 	\item Дэд классад арга нь эх классын аргатай ижил эсвэл хийсвэр тооны параметртэй байна. Учир нь, хэрэв клиент нь дэд классын арга руу илүү ерөнхий объект өгвөл асуудал үүснэ.
	% 	\item Дэд классын аргын буцах төрөл нь эх классын аргын буцах төрөлтэй ижил эсвэл түүний дэд төрөл нь байна.
	% 	\item Дэд классын арга нь эх класст байгаагүй онцгой тохиолдолд үүсгэдэггүй байх ёстой. Үүнийг try-catch блок ашиглан шийддэг.
	% 	\item Дэд класс нь өмнөх нөхцлийг ихэсгэхгүй байх ёстой. Учир нь, ямар ч асуудалгүй ажиллаж байсан утгыг дэд классын аргад параметр болгон дамжуулахад алдаа гарч, клиент кодыг өөрчлөх шаардлага үүсэх болно.
	% 	\item Дэд класс нь дараах нөхцлийг багасгахгүй байх ёстой. Учир нь, клиент код дээрх үнэн гэж үзэж байгаа зүйлсийг өөрчлөх эрсдэлтэй.
	% 	\item Эх классын инвариантийг хэвээр нь үлдээх, өөрөөр хэлбэл байгаа талбаруудыг оролдохгүйгээр шинэ талбаруудыг нэмэх. Инвариант нь гадна интерфейс байдлаар, мөн арга доторх assertion буюу нөхцөл шалгалт байдлаар оршиж болно.
	% 	\item Дэд класс нь эх классын private талбаруудын утгыг өөрчлөх ёсгүй.
	% \end{itemize}
	\item \textbf{Interface Segregation Principle}: Том интерфэйсүүдийг жижиг, тодорхой интерфэйсүү- дэд хуваах ёстой. Ингэснээр клиент хэрэгцээгүй аргуудыг хэрэгжүүлэх шаардлагагүй болно.
	\item \textbf{Dependency Inversion Principle}: Өндөр түвшний модульууд нь доод түвшний модулиу- даас бус харин илүү хийсвэр түвшнээс хамааралтай байх ёстой. Энэ нь кодыг уян хатан, дахин ашиглах боломжтой болгодог.
\end{itemize}
\section{Програм хангамжийн зохиомжийн үлгэр загварууд: Байгуулалтын, Бүтцийн, Зан байдлын}
Зохиомжийн үлгэр загвар нь програм хангамжийн зохиомжийн нийтлэг асуудлуудад бат- лагдсан, дахин ашиглах боломжтой шийдэл юм. Уг нэршлийг 1994 онд "Gang of Four" (GoF) алдаршуулж, хөгжүүлэгчдийн нийтлэг үгсийн сангийн нэг болсон. Ихэнх үлгэр загварыг маш формал байдлаар тайлбарласан байдаг бөгөөд тухайн нөхцөл байдалд тохируулан хуулбар- лаж ашигладаг. Үлгэр загварын тайлбарт ихэвчлэн байдаг хэсгүүд нь:
\begin{itemize}
	\item \textbf{Интент} нь асуудал болон шийдлийн аль алиныг нь товч тайлбарладаг.
	\item \textbf{Хүсэл эрмэлзэл} нь асуудал болон шийдлийг боломжтой болгохыг цааш нь тайлбарладаг.
	\item \textbf{Классуудын бүтэц} нь үлгэр загварын хэсэг бүр, тэдгээр нь хэрхэн уялдаж байгааг харуулдаг.
	\item Түгээмэл програмчлалын хэлнүүдийн нэг дэх \textbf{кодын жишээ} нь үлгэр загварын цаад санааг ойлгоход хялбар болгодог.
\end{itemize}
% Үлгэр загваруудыг дотор нь гурван төрөлд хувааж болно:
% \begin{itemize}
% 	\item Creational үлгэр загварууд нь уян хатан байдлыг нэмэгдүүлэх, класс болон багцуудыг дахин ашиглахын тулд объект байгуулах ажлыг зохицуулдаг;
% 	\item Structural үлгэр загварууд нь класс болон объектуудыг уян хатан байлгахын зэрэгцээ том бүтэц болгон хэрхэн бүрдүүлэх талаар авч үздэг;
% 	\item Behavioral үлгэр загварууд нь объект хоорондын холбоос, үүргийг тодорхойлох, хяналтын урсгал болон алгоритмыг удирдах талаар тусгасан байдаг.
% \end{itemize}
\subsection{Байгуулалтын үлгэр загварууд}
Байгуулалтын үлгэр загварууд нь уян хатан байдлыг нэмэгдүүлэх, класс болон модулиудыг дахин ашиглахын тулд объект байгуулах ажлыг зохицуулдаг.

\subsubsection{"Singleton" үлгэр загвар}
\quad \quad Класст зөвхөн нэг тохиолдол байгаа эсэхийг баталгаажуулж, түүнд хандах глобал хандал- тын цэгийг үүсгэнэ.
Практикт энэ класс нь private байгуулагчтай бөгөөд цорын ганц заагчийг буцаах статик аргатай (эсвэл үүнтэй төстэй) гэсэн үг юм. Энэ үлгэр загвар нь систем дэх үйлдлийг зохицуулахад яг нэг объект шаардлагатай үед хэрэг болно. Гол шинж чанар нь:
\begin{itemize}
	\item Нэг классын заагч буюу нэг глобал объектыг баталгаажуулдаг.
	\item Глобал хандалтын цэгээр, жишээ нь getInstance() аргаар хангадаг.
	\item Ихэвчлэн "lazy initialization"\footnote{"lazy initialization" гэдэг нь объект байгуулах эсвэл утгыг тооцолох ажлыг програмыг эхлүүлэх үед биш, харин анх удаа хэрэг болох хүртэл хойшлуулдаг оновчлолын арга зам бөгөөд хэзээ ч ашиглагдахгүй объект байгуулахаас зайлсхийж, програмыг эхлүүлэх хугацааг багасгаж, санах ойн ашиглалтыг бууруулдаг.} арга замыг ашигладаг бөгөөд тредийн аюулгүй байдлын механизмуудыг агуулж болно.
\end{itemize}
Дундын нөөц эсвэл тохиргоог удирдахад энэ үлгэр загвар ихэвчлэн ашиглагддаг. Жишээлбэл, Java-ийн үндсэн ангиуд java.lang.Runtime болон java.awt.Desktop нь синглтон үлгэр загвараар хэрэгжүүлэгдсэн байдаг. \\
\textbf{Давуу тал}: Нөөц эсвэл үйлчилгээнд глобал хэмжээнд хандах хандалтыг хялбаршуулдаг. Олон клиент ханддаг байсан ч зөвхөн нэг объект үүсдэг. Мөн lazy initialization нь зөвхөн эхний хэрэглээнд л заагч үүсгэх замаар нөөцийг хэмнэх боломжтой. \\
\textbf{Сул тал}: Глобал төлөв үүсгэх учир кодыг тестлэхэд хэцүү болгож, далд хамааралтай байдалд хүргэж болзошгүй. Нэг классад заагчийн хяналтыг зохицуулах замаар Single Responsibility Principle зарчмыг зөрчиж байна. Болгоомжтой хэрэгжүүлээгүй тохиолдолд конкуррент асууд- лууд үүсэж, тредтэй холбоотой нэмэлт код шаарддаг.

\subsubsection{"Factory Method" үлгэр загвар}
\quad \quad Объект байгуулах интерфэйс эсвэл хийсвэр аргыг тодорхойлдог боловч дэд классуудад аль конкрет классаар объектыг байгуулахыг шийдэх боломжийг олгодог. Үнэн хэрэгтээ объект байгуулах ажлыг үйлдвэрийн дэд классуудад буюу \textit{үйлдвэрүүдэд} томилон илгээдэг. Энэ нь клиент кодыг конкрет бүтээгдэхүүн классаас салгадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлдвэрийн интерфэйсийн ард объект байгуулах ажлыг битүүмжилдэг.
	\item Дэд классууд нь өөр өөр бүтээгдэхүүн буцаахын тулд үйлдвэрийн аргыг дарж бичдэг.
	\item Клиент нь ямар конкрет төрлөөр бүтээгдсэнийг мэдэхгүйгээр үйлдвэрийн интерфейсийг ашигладаг.
	\item Клиент кодыг өөрчлөхгүйгээр шинэ бүтээгдэхүүн нэмэх боломжийг олгодог.
\end{itemize}
Класс нь аль дэд классыг байгуулах ёстойг урьдчилан таамаглах боломжгүй үед энэ үлгэр загвар ашиглагддаг. Жишээлбэл, GUI фреймворк нь платформд тусгайлан зориулсан UI элементүүдийг үүсгэхийн тулд үйлдвэрүүдийг ашиглаж болно. Мөн Жава стандарт сан болон фреймворкуудад өргөн хэрэглэгддэг, жишээ нь Spring, Struts.\\
\textbf{Давуу тал}: Үйлдвэрийн шинэ дэд классуудыг нэмснээр шинэ бүтээгдэхүүн нэвтрүүлэхэд хялбар. Клиент нь конкрет бүтээгдэхүүн классаас бус зөвхөн үйлдвэрийн интерфейсээс хамаар- даг. Ингэснээр байгуулах логикийг бизнесийн логикоос тусгаарлаж өгдөг.\\
\textbf{Сул тал}: Үйлдвэрийн дэд классуудад нэмэлт класс үүсгэх шаардлагатай бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг. Зарим тохиолдолд бүтээгдхүүний төрөл бүрийн хувилбаруудыг дэм- жихийн тулд олон үйлдвэр хэрэгтэй болдог.

\subsubsection{"Abstract Factory" үлгэр загвар}
\quad \quad Конкрет классыг тодорхойлохгүйгээр холбоотой эсвэл хамааралтай объектуудын \textit{гэр бүлийг} үүсгэх интерфейсээр хангадаг. Энэ нь үндсэндээ "үйлдвэрүүдийн үйлдвэр" юм. Хийсвэр үйлдвэр нь бүтээгдэхүүн тус бүрийг бий болгох аргыг тодорхойлдог бөгөөд конкрет үйлдвэр- ийн дэд классууд нь конкрет хэрэгжүүлэлтээр хангадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Хамтдаа ажиллахад зориулагдсан хоорондоо холбоотой объектуудын бүлгүүд буюу бүтээгдэхүүнийг үүсгэдэг.
	\item Клиентад тодорхой конкрет классаас хамааралгүйгээр бүтээгдэхүүний гэр бүлийг буцаана.
	\item Конкрет үйлдвэр бүр нь гэр бүлийн бүх бүтээгдэхүүнийг бий болгох аргыг хэрэгжүүлдэг.
\end{itemize}
Аппликешныг олон төрлийн бүтээгдэхүүний аль нэгэнд тохируулах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Сонгодог жишээ бол олон янзын харагдах байдлыг дэмждэг UI хэрэгсэл юм. AbstractWidgetFactory нь товчлуур, текст хайрцаг, цэс үүсгэж болох ба конкрет үйлдвэрүүд Windows эсвэл Mac загварын хувилбаруудыг үйлдвэрлэдэг.\\
\textbf{Давуу тал}: Хоорондоо холбоотой бүтээгдэхүүнүүдийг нийцэмжтэй байдлаар хангана. Клиент код нь зөвхөн үйлдвэрийн интерфейстэй ажиллах боломжтой. Мөн үйлдвэрийн дэд классуудыг солилцох замаар өөр өөр бүтээгдэхүүний гэр бүл үүсгэдэг. \\
\textbf{Сул тал}: Маш олон үйлдвэр, бүтээгдэхүүн классаас хамардаг. Гэр бүлд шинэ бүтээгдэхүүн нэмэхийн тулд хийсвэр интерфейсийг өөрчлөх шаардлагатай нь зохиомжийн Open/Closed зарчмыг зөрчдөг. Конкрет хийсвэр үйлдвэрийн класс нь холбогдох бүтээгдэхүүн бүрийг үйлдвэрлэхийн тулд олон үйлдвэрийн аргын дуудлага ашигладаг.

\subsubsection{"Builder" үлгэр загвар}
\quad \quad Нарийн төвөгтэй объект байгуулах үйл явцыг алхам алхмаар тусгаарлах боломжийг олгодог. Энэ нь ижил байгуулах үйл явцыг ашиглан өөр өөр дүрслэлийг бий болгох боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Нарийн төвөгтэй объектуудыг үе шаттайгаар байгуулдаг, жишээ нь олон нэмэлт хэсгүүд эсвэл үүрлэсэн дэд объектуудтай нь хамт.
	\item \textit{Барилгачин} класс нь эд ангиудыг цуглуулж, эцсийн объектыг build() аргаар угсардаг.
	% хэд хэдэн аргын дуудлагыг гинжлэх замаар объектыг тохируулах програмчлалын уншигдахуйц байдлыг нэмэгдүүлдэг.
	\item Захиалагч нь байгуулагчийн интерфэйсээр дамжуулан объект байгуулах үйл явцыг удирд- даг. Барилгачин класс нь харин объект үүсгэх ажлыг зохицуулдаг.
\end{itemize}
Объект нь олон хэсэг эсвэл хослолын сонголтуудыг шаарддаг бөгөөд энэ нь олон тооны байгуулагчуудыг хэт ачаалахад хүргэх нөхцөлд энэ үлгэр загварыг ашигладаг. Жишээ нь, олон сонголттой хоол бүхий хоолны иж бүрдлийг хийх, эсвэл нэмэлт талбар бүхий хэрэглэгчийг байгуулах зэрэг орно. Энэ нь өөрчлөгдөшгүй объектууд эсвэл тохиргооны хүнд объектуудыг (жишээ нь, өгөгдлийн сангийн холболтын тохиргоо, нарийн төвөгтэй GUI бүрэлдэхүүн хэсгүүд) бүтээхэд түгээмэл байдаг.\\
\textbf{Давуу тал}: Хэд хэдэн аргын дуудалтыг гинжлэх замаар програмын уншигдахуйц байдлыг нэмэгдүүлдэг. Байгуулагчын бичдэсийг өөрчлөхгүйгээр нэмэлт параметр эсвэл алхамуудыг хялбархан нэмж болно. Барилгачин объект нь өөрөө түр зуурын, өөрчлөгддөг контейнер бөгөөд эцсийн өөрчлөгддөггүй объектыг бүтээх хүртэл бүх тохиргооны мэдээллийг хадгалдаг.\\
\textbf{Сул тал}: Үйл явцыг хянахын тулд нэмэлт класс үүсгэх шаардлагатай бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг.	Бүтээгдэхүүн тус бүрт барилгачин класс хэрэгтэй бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг. Энгийн объектуудын хувьд хэт их байж болно.

\subsubsection{"Prototype" үлгэр загвар}
\quad \quad Энэ үлгэр загвар нь бүтээгдэхүүний заагчийг ашиглан шинэ объект үүсгэх боломжийг олгодог. Энэ нь шинэ объект байгуулахын оронд одоо байгаа объектыг хуулбарлах замаар шинэ объект үүсгэдэг. Ингэхдээ конкрет \textit{прототипийг} хэрэгжүүлдэг ихэвчлэн нэг аргатай clone() интерфейсийг зарладаг. Клиент нь классуудыг шууд үүсгэхийн оронд прототипийг өөрөө хувилахыг асуух замаар шинэ объектуудыг шаарддаг. Гол шинж чанар нь:
\begin{itemize}
	\item Объектыг хувилах ажлыг тухайн объектод томилон илгээдэг.
	\item Кодыг конкрет классуудтай холбохоос зайлсхийдэг учир код нь ганц ерөнхий "prototype" интерфейстэй харьцдаг.
	\item Объект байгуулах нь үнэтэй эсвэл төвөгтэй үед ашигтай байдаг, өөрөөр хэлбэл одоо байгаа прототипийг хуулбарлах нь илүү хялбар байх болно.
\end{itemize}
Ижил төстэй эсвэл эхнээс нь байгуулахад үнэтэй объектуудыг бүтээхэд хэрэгтэй.\\
\textbf{Давуу тал}: Клиент хувилах объектын классыг мэдэх шаардлагагүй ба одоо байгаа прототипүүд- ийг хувилах замаар дахин давтагдах кодыг арилгах боломжтой. Мөн програм ажиллаж байх үед шинэ прототип нэмэхэд хялбар.\\
\textbf{Сул тал}: Тойрог үүсгэн нэг нэгнээ зааж хандсан эсвэл гадаад нөөцөөс хамаарсан нарийн төвөгтэй объектуудыг хувилах нь төвөгтэй эсвэл алдаатай байж болно. Класс бүрт  clone()  аргыг хэрэг- жүүлэх ёстой. Гүн ба гүехэн\footnote{
	Гүехэн хуулах: Объектын дээд түвшний шинж чанаруудыг хуулах боловч эх хувийн аль ч үүрлэсэн объектыг бус түүний заагчийг оноодог.
	Гүн хуулах: Шинэ объект үүсгэж, бүх үүрлэсэн объектуудыг давталттайгаар хуулбарлаж, хуулбар нь эх хувилбараас бүрэн хамааралгүй эсэхийг баталгаажуулна.
} хуулалттай холбоотой асуудлуудыг анхааралтай авч үзэх шаардлагатай.

\subsection{Бүтцийн үлгэр загварууд}
Бүтцийн үлгэр загварууд нь класс болон объектуудыг уян хатан байлгахын зэрэгцээ том бүтэц болгон хэрхэн бүрдүүлэх талаар авч үздэг.




% Эндээс засварлана
% \subsubsection{Adapter үлгэр загвар}
% \quad \quad Нэг интерфэйсийг өөр интерфэйс рүү хөрвүүлэх боломжийг олгодог. Энэ нь өөр интерфэйсийг шаарддаг клиентүүдэд зориулж хуучин эсвэл таарахгүй интерфэйс бүхий объектуудыг ашиглах боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Клиент болон үйлчилгээг үзүүлэгчийн хоорондох интерфэйсийн зөрүүг арилгах.
% 	\item \textit{Адаптер} класс нь үйлчилгээг үзүүлэгчийн интерфэйсийг хэрэгжүүлдэг бөгөөд дараа нь үйлчилгээг үзүүлэгчийн объект руу дуудлага дамжуулдаг.
% 	\item Клиент нь зөвхөн адаптерийн интерфэйстэй харьцдаг.
% \end{itemize}
% Хуучин кодыг шинэ систем эсвэл шинэ интерфэйс шаарддаг гуравдагч талын номын сан эсвэл API-тэй нэгтгэхэд ашигладаг. Жишээ нь, Java-ийн InputStreamReader класс нь InputStream (байт урсгал)- ийг Reader (тэмдэгт урсгал) интерфэйс рүү хөрвүүлдэг.\\
% \textbf{Давуу тал}: Хуучин кодыг шинэ системд дахин ашиглах боломжийг олгодог. Клиент болон үйлчилгээг үзүүлэгчийн хоорондох хамаарлыг бууруулдаг. Мөн олон үйлчилгээг үзүүлэгчийн интерфэйсийг нэг адаптерээр нэгтгэх боломжийг олгодог.\\
% \textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд адаптер нь үйлчилгээг үзүүлэгчийн интерфэйсийг бүрэн дэмжихгүй байж болно.

% \subsubsection{Bridge Pattern}
% \quad \quad Абстракц болон түүний хэрэгжилтийг тусгаарлах боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Абстракц болон түүний хэрэгжилтийг тусгаарлах.
% 	\item Абстракц нь хэрэгжилтийн интерфэйсийг агуулдаг бөгөөд дараа нь хэрэгжилтийн объект руу дуудлага дамжуулдаг.
% 	\item Клиент нь зөвхөн абстракцын интерфэйстэй харьцдаг.
% \end{itemize}
% Абстракц болон түүний хэрэгжилт нь өөр өөр шалтгаанаар өөрчлөгдөж болзошгүй үед энэ үлгэр загварыг ашигладаг. Жишээ нь, график хэрэглэгчийн интерфэйсийн элементүүдийг (жишээ нь, товчлуур, текст хайрцаг) платформ тус бүрийн хэрэгжилтээс тусгаарлаж болно.\\
% \textbf{Давуу тал}: Абстракц болон түүний хэрэгжилтийг тусгаарлах боломжийг олгодог. Абстракц болон хэрэгжилтийн аль алиныг нь бие даан өөрчлөх боломжийг олгодог. Мөн олон хэрэгжилтийн хувилбаруудыг дэмжихэд хялбар.\\
% \textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд абстракц нь хэрэгжилтийн интерфэйсийг бүрэн дэмжихгүй байж болно.	

\subsubsection{"Composite" үлгэр загвар}
\quad \quad Объектуудыг мод бүтэц болгон зохион байгуулж,	 нэгж болон бүрэлдэхүүн хэсгүүдтэй ижил байдлаар харьцах боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Композит болон навчны объектууд ижил интерфэйсийг хэрэгжүүлдэг.
	\item Композит объект нь хүүхэд объектуудын цуглуулгыг агуулж, хүүхэд объектууд дээр үйлдлүүдийг рекурсивээр гүйцэтгэдэг.
	\item Клиент нь композит болон навч объектуудтай ижил байдлаар харьцдаг.
\end{itemize}
Ижил төрлийн объектуудын ижил үйлдлийг нэгтгэх шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, график хэрэглэгчийн интерфэйсийн элементүүдийг (жишээ нь, цэс, товчлуур, текст хайрцаг) мод бүтэц болгон зохион байгуулж, хэрэглэгчийн интерфэйсийг ижил байдлаар удирдах боломжийг олгодог. Бидний мэдэх React.js \footnote{https://react.dev/}-ийн бүрэлдэхүүн загвар болон түүний жижиг бие даасан нэгжүүдийг хослуулан UI-г бий болгох арга нь энэ үлгэр загварын зарчим, давуу талыг шууд тусгасан байдаг.\\	
\textbf{Давуу тал}: Композит болон навч объектуудыг ижил байдлаар авч үзэх боломжийг олгодог. Композит бүтэц нь динамикаар өөрчлөгдөж, шинэ хүүхэд объектуудыг нэмэх эсвэл устгах боломжтой. Мөн модны бүтцийн бүх түвшинд үйлдлүүдийг рекурсивээр гүйцэтгэх боломжийг олгодог.\\
\textbf{Сул тал}: Композит бүтэц нь төвөгтэй бөгөөд удирдах, ойлгоход хэцүү байж болно. Зарим тохиолдолд навч объектуудыг композит объектуудаас ялгах нь төвөгтэй байж болно.

\subsubsection{"Decorator" үлгэр загвар}
\quad \quad Нэг классын бусад объектод нөлөөлөхгүйгээр тухайн объектод үйлдлийг динамикаар нэмдэг. \textit{Декоратор} нь анхны объектыг баглаж\footnote{"Wrapped object" гэдэг нь анхны объектын заагчийг агуулсан декоратор бөгөөд ижил интерфейсийг хэрэгжүүлдэг. Энэ нь зурвасыг \textit{баглаж} байгаа анхны объект руу шилжүүлэхээс өмнө эсвэл дараа нь өөрийн логикийг гүйцэтгэх замаар шинэ аргыг нэмж эсвэл одоо байгаа аргыг өөрчилдөг.}, түүнд ажлыг томилон илгээхээс өмнө/дараа нэмэлт үйлдэл хийх чадамжаар хангадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлдлийг нэмэх эсвэл өөрчлөхийн тулд тухайн объектын оронд декоратор объект ашиг- ладаг. 
	\item Декоратор класс нь багласан объекттой ижил интерфэйсийг хэрэгжүүлж, зан төлөвийг нэмдэг бөгөөд дараа нь анхны объект руу зурвас дамжуулдаг.
	\item Олон тооны декоратор объектыг давхарга болгон баглаж болно.
\end{itemize}
Програм ажиллаж байх үед арга нэмэхэд ихэвчлэн ашиглагддаг. Жишээлбэл, Жава хэлний I/O урсгалууд нь үндсэн InputStream-д аргыг буферлэхийн тулд BufferedInputStream гэх мэт декораторуудыг ашигладаг. GUI кодын хувьд цонхонд гүйлгэх мөр эсвэл хүрээ нэмэхийг мөн декоратороор хийж болно.\\
\textbf{Давуу тал}: Объектын үйлдлийг динамикаар нэмэх эсвэл өөрчлөх боломжийг олгодог. Анхны класс эсвэл модулийг өөрчлөхгүйгээр шинэ функц нэмэх боломжийг олгодог нь Open/Closed зарчмыг дэмждэг. Мөн олон декораторуудыг рекурсивээр холбож, олон төрлийн үйлдэл хийх чадамжтай объектуудыг бий болгох боломжийг олгодог.\\
\textbf{Сул тал}: Үр дүнд нь олон жижиг классууд бий болох ба багласан объектыг тестлэх эсвэл дибаг хийхэд хэцүү байж болно.
% \subsubsection{Facade үлгэр загвар}
% \quad \quad Нэг буюу хэд хэдэн нарийн төвөгтэй систем, номын сангийн энгийн интерфэйсийг хангадаг. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Нарийн төвөгтэй систем, номын сангийн ард энгийн интерфэйсийг хангадаг.
% 	\item Фасад класс нь нарийн төвөгтэй системийн олон үйлдлийг нэгтгэж, энгийн аргаар дамжуулдаг.
% 	\item Клиент нь зөвхөн фасадын интерфэйстэй харьцдаг.
% \end{itemize}
% Нарийн төвөгтэй систем, номын санг хялбархан ашиглах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн JDBC API нь өгөгдлийн сантай харьцахын тулд фасадын интерфэйсийг хангадаг.\\
% \textbf{Давуу тал}: Нарийн төвөгтэй систем, номын санг хялбархан ашиглах боломжийг олгодог	. Клиент болон нарийн төвөгтэй системийн хоорондох хамаарлыг бууруулдаг. Мөн нарийн төвөгтэй системийн олон үйлдлийг нэгтгэж, энгийн аргаар дамжуулдаг.\\	
% \textbf{Сул тал}: Фасад нь нарийн төвөгтэй системийн бүх функцэд хандах боломжийг хангахгүй байж болно. Зарим тохиолдолд фасад нь нарийн төвөгтэй системийн интерфэйсийг бүрэн дэмжихгүй байж болно.

% \subsubsection{Flyweight үлгэр загвар}
% \quad \quad Их хэмжээний объектуудыг үр ашигтайгаар удирдах боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Их хэмжээний объектуудыг хуваалцах замаар санах ойг хэмнэх.
% 	\item \textit{Flyweight} класс нь хуваалцсан өгөгдөл (жишээ нь, дүрслэл, төлөв) болон хуваалцдаггүй өгөгдөл (жишээ нь, байрлал, төлөв)- ийг агуулдаг.
% 	\item Клиент нь зөвхөн flyweight-ийн интерфэйстэй харьцдаг.
% \end{itemize}
% Их хэмжээний ижил төстэй объектуудыг удирдах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, текст засварлагч нь ижил үсэг дүрсүүдийг хуваалцаж, санах ойг хэмнэхийн тулд flyweight үлгэр загварыг ашиглаж болно.\\
% \textbf{Давуу тал}: Их хэмжээний объектуудыг үр ашигтайгаар удирдах боломжийг олгодог. Санах ойг хэмнэхийн тулд ижил төстэй объектуудыг хуваалцдаг. Мөн flyweight объектуудыг дахин ашиглах боломжийг олгодог.\\
% \textbf{Сул тал}: Flyweight объектуудыг зохицуулахын тулд нэмэлт төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд flyweight нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.	

% \subsubsection{Proxy үлгэр загвар}
% \quad \quad Бусад объект руу хандах хяналтын цэгийг хангадаг. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтын цэгийг хангадаг.
% 	\item Прокси класс нь үйлчилгээг үзүүлэгчийн интерфэйсийг хэрэгжүүлдэг бөгөөд дараа нь үйлчилгээг үзүүлэгчийн объект руу дуудлага дамжуулдаг.
% 	\item Клиент нь зөвхөн проксийн интерфэйстэй харьцдаг.
% \end{itemize}
% Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтыг хэрэгтэй үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн RMI (Remote Method Invocation) нь алсын объект руу хандах прокси объектуудыг үүсгэдэг.\\
% \textbf{Давуу тал}: Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтыг хангадаг. Үйлчилгээг үзүүлэгчийн объектын амьдралын мөчлөгийг удирдах боломжийг олгодог. Мөн үйлчилгээг үзүүлэгчийн объект руу хандах өмнөх боловсруулалт (жишээ нь, кэшлэх, аюулгүй байдал)- ийг гүйцэтгэх боломжийг олгодог.\\
% \textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд прокси нь үйлчилгээг үзүүлэгчийн интерфэйсийг бүрэн дэмжихгүй байж болно.		

\subsection{Зан төлөвийн үлгэр загварууд}
Зан төлөвийн үлгэр загварууд нь объект хоорондын холбоос, үүргийг тодорхойлох, хяналтын урсгал болон алгоритмыг удирдах талаар тусгасан байдаг.

% \subsubsection{Observer үлгэр загвар}
% \quad \quad Нэг объектын төлөв өөрчлөгдөхөд хамааралтай объектуудад автоматаар мэдэгдэх боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Нэг объект (subject) нь өөрт хамааралтай олон объектууд (observers)- ыг удирддаг.
% 	\item Subject объект нь төлөвийн өөрчлөлтийг observers объектуудад мэдэгддэг.
% 	\item Observers объектууд нь subject объектын төлөвийн өөрчлөлтөд хариу үйлдэл үзүүлдэг.
% \end{itemize}
% Үйл явдлын хяналт, үйл явдлын хариу үйлдэл, эсвэл тараах системд энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Swing фреймворк нь товчлуур дээр дарах зэрэг үйл явдлуудыг хянахын тулд observer үлгэр загварыг ашигла	даг.\\
% \textbf{Давуу тал}: Объект хоорондын сул хамаарлыг хангадаг. Subject болон observers объектуудыг бие даан өөрчлөх боломжийг олгодог. Мөн олон observers объектуудыг нэг subject объекттой холбох боломжийг олгодог.\\
% \textbf{Сул тал}: Observers объектуудын тоо их байх үед гүйцэтгэлд нөлөөлж болзошгүй.	

% \subsubsection{Strategy үлгэр загвар}	
% \quad \quad Нэг алгоритмыг өөр алгоритмтай солих боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Алгоритмыг тусгаарлахын тулд хийсвэр \textit{стратеги} интерфэйсийг тодорхойлдог.
% 	\item Тус интерфэйсийг хэрэгжүүлдэг олон \textit{конкрет стратеги} классууд байдаг.
% 	\item Клиент нь стратеги интерфэйсээр дамжуулан алгоритмыг сонгодог.
% \end{itemize}
% Алгоритмыг сонгох эсвэл өөрчлөх шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Collections.sort() аргыг нь янз бүрийн эрэмбэлэх стратегиудыг (жишээ нь, өсөх, буурах) дэмжихийн тулд стратеги үлгэр загварыг ашигладаг.\\
% \textbf{Давуу тал}: Алгоритмыг бие даан өөрчлөх боломжийг олгодог. Клиент нь зөвхөн стратеги интерфэйстэй харьцдаг. Мөн шинэ стратеги классуудыг хялбархан нэмж болно.\\
% \textbf{Сул тал}: Нэмэлт төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд стратеги нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.

% \subsubsection	{Command үлгэр загвар}
% \quad \quad Үйлдлийг объект болгон төлөөлөх боломжийг олгодог. Гол шинж чанар нь:
% \begin{itemize}
% 	\item Үйлдлийг гүйцэтгэхийн тулд \textit{комманд} объект ашигладаг.
% 	\item Комманд класс нь үйлдлийг гүй		цэтгэхийн тулд \textit{гүйлгэх} аргыг хэрэгжүүлдэг.
% 	\item Клиент нь зөвхөн коммандын интерфэйстэй харьцдаг.
% \end{itemize}
% Командуудыг хадгалах, дараах байдлаар гүйцэтгэх, эсвэл буцаах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Swing фреймворк нь товчлуур дээр дарах зэрэг үйлдлүүдийг гүйцэтгэхийн тулд комманд үлгэр загварыг ашигладаг.\\
% \textbf{Давуу тал}: Үйлдлийг объект болгон төлөөлөх боломжийг олгодог. Коммандуудыг хадгалах, дараах байдлаар гүйцэтгэх, эсвэл буцаах боломжийг олгодог. Мөн шинэ комманд классуудыг хялбархан нэмж болно.\\
% \textbf{Сул тал}: Нэмэлт төвөгтэй байдлыг нэмж о	руулдаг. Зарим тохиолдолд комманд нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.	

\subsubsection{Iterator үлгэр загвар}
\quad \quad Цуглуулгын элементүүдээр дараалалтайгаар нэвтрэх боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Цуглуулгын элементүүдээр нэвтрэхийн тулд \textit{итератор} объект ашигладаг.
	\item Элементүүдээр нэвтрэхийн тулд \textit{next()} болон \textit{hasNext()} аргуудыг хэрэгжүүлдэг.
	\item Клиент нь зөвхөн итераторын интерфэйстэй харьцдаг.
\end{itemize}
Цуглуулгын элементүүдээр дараалалтайгаар нэвтрэх шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Collection фреймворк нь List, Set, Map зэрэг цуглуулгуудыг нэвтрэхийн тулд итератор үлгэр загварыг ашигладаг.\\
\textbf{Давуу тал}: Цуглуулгын элементүүдээр дараалалтайгаар нэвтрэх боломжийг олгодог. Цуглуул- гын доторх бүтэц болон төлөвийг далдлах боломжийг олгодог. Мөн олон төрлийн цуглуулгуудыг ижил байдлаар нэвтрэх боломжийг олгодог.\\
\textbf{Сул тал}: Нэмэлт төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд итератор нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.