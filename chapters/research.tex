Програм хангамжийн зохиомж нь програм хангамжийн системийн бүтэц, түүний бүрэлдэхүүн хэсгүүдийн харилцан үйлчлэл, зан төлөвийг тодорхойлох үйл явц юм. Энэ нь програм хангам -жийн хөгжүүлэлтийн амжилтын гол хүчин зүйл бөгөөд системийн чанар, уян хатан байдал, засвар үйлчилгээний чадамжид шууд нөлөөлдөг. Зохиомж нь системийн шаардлага, бизнес -ийн зорилго, техникийн хязгаарлалтыг ойлгох, эдгээрийг зохицуулсан шийдэл гаргахыг шаарддаг.
\section{Програм хангамжийн зохиомжийн зарчмууд}
Програм хангамжийн зохиомжийн зарчмууд нь сайн зохиомжийг бий болгоход чиглэсэн удирдамж, хамгийн сайн туршлагуудын цуглуулга юм. Эдгээр зарчмууд нь програм хангам -жийн системийг уян хатан, дахин ашиглах боломжтой, засвар үйлчилгээ хийхэд хялбар болгоход тусалдаг. SOLID зарчмуудыг доор дурдлаа:
\begin{itemize}
	\item \textbf{"Single Responsibility Principle"}: Класс эсвэл модуль нь зөвхөн нэг л шалтгаанаар өөрчлөг -дөх ёстой. Энэ нь кодыг илүү ойлгомжтой, засвар үйлчилгээ хийхэд хялбар болгодог.
	\item \textbf{"Open/Closed Principle"}: Програм хангамжийн элементүүд нь өргөтгөхөд нээлттэй, өөрч -лөхөд хаалттай байх ёстой. Энэ нь шинэ функц нэмэхдээ одоо байгаа кодыг өөрчлөхгүй байхыг шаарддаг.
	\item \textbf{"Liskov Substitution Principle"}: Суперклассын объектуудыг түүний дэд классын объектуу -даар орлуулах боломжтой байх ёстой. Энэ нь полиморфизмын үндсэн зарчим бөгөөд кодыг илүү уян хатан болгодог.
	\item \textbf{"Interface Segregation Principle"}: Том интерфэйсүүдийг жижиг, тодорхой интерфэйсүүдэд хуваах ёстой. Ингэснээр клиент хэрэгцээгүй аргуудыг хэрэгжүүлэх шаардлагагүй болно.
	\item \textbf{"Dependency Inversion Principle"}: Өндөр түвшний модульууд нь доод түвшний модулиу -даас бус харин илүү хийсвэр түвшнээс хамааралтай байх ёстой. Энэ нь кодыг уян хатан, дахин ашиглах боломжтой болгодог.
\end{itemize}
\section{Програм хангамжийн зохиомжийн үлгэр загварууд: Creational, Structural, Behavioral}
Зохиомжийн үлгэр загвар нь програм хангамжийн зохиомжийн нийтлэг асуудлуудад бат -лагдсан, дахин ашиглах боломжтой шийдэл юм. Уг нэршлийг 1994 онд "Gang of Four" (GoF) алдаршуулж, хөгжүүлэгчдийн нийтлэг үгсийн сангийн нэг болсон.
% Үлгэр загваруудыг дотор нь гурван төрөлд хувааж болно:
% \begin{itemize}
% 	\item Creational үлгэр загварууд нь уян хатан байдлыг нэмэгдүүлэх, класс болон багцуудыг дахин ашиглахын тулд объект байгуулах ажлыг зохицуулдаг;
% 	\item Structural үлгэр загварууд нь класс болон объектуудыг уян хатан байлгахын зэрэгцээ том бүтэц болгон хэрхэн бүрдүүлэх талаар авч үздэг;
% 	\item Behavioral үлгэр загварууд нь объект хоорондын холбоос, үүргийг тодорхойлох, хяналтын урсгал болон алгоритмыг удирдах талаар тусгасан байдаг.
% \end{itemize}
\subsection{Creational үлгэр загварууд}
Creational үлгэр загварууд нь уян хатан байдлыг нэмэгдүүлэх, класс болон модулиудыг дахин ашиглахын тулд объект байгуулах ажлыг зохицуулдаг.

\subsubsection{Singleton үлгэр загвар}
\quad \quad Класст зөвхөн нэг тохиолдол байгаа эсэхийг баталгаажуулж, түүнд хандах глобал хандал -тын цэгийг үүсгэнэ.
Практикт энэ класс нь private байгуулагчтай бөгөөд цорын ганц заагчийг буцаах статик аргатай (эсвэл үүнтэй төстэй) гэсэн үг юм. Энэ үлгэр загвар нь систем дэх үйлдлийг зохицуулахад яг нэг объект шаардлагатай үед хэрэг болно. Гол шинж чанар нь:
\begin{itemize}
	\item Нэг классын заагч буюу нэг глобал объектыг баталгаажуулдаг.
	\item Глобал хандалтын цэгээр, жишээ нь getInstance() аргаар хангадаг.
	\item Ихэвчлэн "lazy initialization"\footnote{"lazy initialization" гэдэг нь объект байгуулах эсвэл утгыг тооцолох ажлыг програмыг эхлүүлэх үед биш, харин анх удаа хэрэг болох хүртэл хойшлуулдаг оновчлолын арга зам бөгөөд хэзээ ч ашиглагдахгүй объект байгуулахаас зайлсхийж, програмыг эхлүүлэх хугацааг багасгаж, санах ойн ашиглалтыг бууруулдаг.} арга замыг ашигладаг бөгөөд тредийн аюулгүй байдлын механизмуудыг агуулж болно.
\end{itemize}
Дундын нөөц эсвэл тохиргоог удирдахад энэ үлгэр загвар ихэвчлэн ашиглагддаг. Жишээлбэл, Java-ийн үндсэн ангиуд java.lang.Runtime болон java.awt.Desktop нь синглтон үлгэр загвараар хэрэгжүүлэгдсэн байдаг. \\
\textbf{Давуу тал}: Нөөц эсвэл үйлчилгээнд глобал хэмжээнд хандах хандалтыг хялбаршуулдаг. Олон клиент ханддаг байсан ч зөвхөн нэг объект үүсдэг. Мөн lazy initialization нь зөвхөн эхний хэрэглээнд л заагч үүсгэх замаар нөөцийг хэмнэх боломжтой. \\
\textbf{Сул тал}: Глобал төлөв үүсгэх учир кодыг тестлэхэд хэцүү болгож, далд хамааралтай байдалд хүргэж болзошгүй. Нэг классад заагчийн хяналтыг зохицуулах замаар Single Responsibility Principle зарчмыг зөрчиж байна. Болгоомжтой хэрэгжүүлээгүй тохиолдолд конкуррент асууд -лууд үүсэж, тредтэй холбоотой нэмэлт код шаарддаг.

\subsubsection{Factory Method үлгэр загвар}
\quad \quad Объект байгуулах интерфэйс эсвэл хийсвэр аргыг тодорхойлдог боловч дэд классуудад аль конкрет классаар объектыг байгуулахыг шийдэх боломжийг олгодог. Үнэн хэрэгтээ объект байгуулах ажлыг үйлдвэрийн дэд классуудад буюу \textit{үйлдвэрүүдэд} томилон илгээдэг. Энэ нь клиент кодыг конкрет бүтээгдэхүүн классаас салгадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлдвэрийн интерфэйсийн ард объект байгуулах ажлыг битүүмжилдэг.
	\item Дэд классууд нь өөр өөр бүтээгдэхүүн буцаахын тулд үйлдвэрийн аргыг дарж бичдэг.
	\item Клиент нь ямар конкрет төрлөөр бүтээгдсэнийг мэдэхгүйгээр үйлдвэрийн интерфейсийг ашигладаг.
	\item Клиент кодыг өөрчлөхгүйгээр шинэ бүтээгдэхүүн нэмэх боломжийг олгодог.
\end{itemize}
Класс нь аль дэд классыг байгуулах ёстойг урьдчилан таамаглах боломжгүй үед энэ үлгэр загвар ашиглагддаг. Жишээлбэл, GUI фреймворк нь платформд тусгайлан зориулсан UI элементүүдийг үүсгэхийн тулд үйлдвэрүүдийг ашиглаж болно. Мөн Жава стандарт сан болон фреймворкуудад өргөн хэрэглэгддэг, жишээ нь Spring, Struts.\\
\textbf{Давуу тал}: Үйлдвэрийн шинэ дэд классуудыг нэмснээр шинэ бүтээгдэхүүн нэвтрүүлэхэд хялбар. Клиент нь конкрет бүтээгдэхүүн классаас бус зөвхөн үйлдвэрийн интерфейсээс хамаар -даг. Ингэснээр байгуулах логикийг бизнесийн логикоос тусгаарлаж өгдөг.\\
\textbf{Сул тал}: Үйлдвэрийн дэд классуудад нэмэлт класс үүсгэх шаардлагатай бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг. Зарим тохиолдолд бүтээгдхүүний төрөл бүрийн хувилбаруудыг дэм -жихийн тулд олон үйлдвэр хэрэгтэй болдог.

\subsubsection{Abstract Factory үлгэр загвар}
\quad \quad Конкрет классыг тодорхойлохгүйгээр холбоотой эсвэл хамааралтай объектуудын \textit{гэр бүлийг} үүсгэх интерфейсээр хангадаг. Энэ нь үндсэндээ "үйлдвэрүүдийн үйлдвэр" юм. Хийсвэр үйлдвэр нь бүтээгдэхүүн тус бүрийг бий болгох аргыг тодорхойлдог бөгөөд конкрет үйлдвэр -ийн дэд классууд нь конкрет хэрэгжүүлэлтээр хангадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Хамтдаа ажиллахад зориулагдсан хоорондоо холбоотой объектуудын бүлгүүд буюу бүтээгдэхүүнийг үүсгэдэг.
	\item Клиентад тодорхой конкрет классаас хамааралгүйгээр бүтээгдэхүүний гэр бүлийг буцаана.
	\item Конкрет үйлдвэр бүр нь гэр бүлийн бүх бүтээгдэхүүнийг бий болгох аргыг хэрэгжүүлдэг.
\end{itemize}
Аппликешныг олон төрлийн бүтээгдэхүүний аль нэгэнд тохируулах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Сонгодог жишээ бол олон янзын харагдах байдлыг дэмждэг UI хэрэгсэл юм. AbstractWidgetFactory нь товчлуур, текст хайрцаг, цэс үүсгэж болох ба конкрет үйлдвэрүүд Windows эсвэл Mac загварын хувилбаруудыг үйлдвэрлэдэг.\\
\textbf{Давуу тал}: Хоорондоо холбоотой бүтээгдэхүүнүүдийг нийцэмжтэй байдлаар хангана. Клиент код нь зөвхөн үйлдвэрийн интерфейстэй ажиллах боломжтой. Мөн үйлдвэрийн дэд классуудыг солилцох замаар өөр өөр бүтээгдэхүүний гэр бүл үүсгэдэг. \\
\textbf{Сул тал}: Маш олон үйлдвэр, бүтээгдэхүүн классаас хамардаг. Гэр бүлд шинэ бүтээгдэхүүн нэмэхийн тулд хийсвэр интерфейсийг өөрчлөх шаардлагатай нь зохиомжийн Open/Closed зарчмыг зөрчдөг. Конкрет хийсвэр үйлдвэрийн класс нь холбогдох бүтээгдэхүүн бүрийг үйлдвэрлэхийн тулд олон үйлдвэрийн аргын дуудлага ашигладаг.

\subsubsection{Builder үлгэр загвар}
\quad \quad Нарийн төвөгтэй объект байгуулах үйл явцыг алхам алхмаар тусгаарлах боломжийг олгодог. Энэ нь ижил байгуулах үйл явцыг ашиглан өөр өөр дүрслэлийг бий болгох боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Нарийн төвөгтэй объектуудыг үе шаттайгаар байгуулдаг, жишээ нь олон нэмэлт хэсгүүд эсвэл үүрлэсэн дэд объектуудтай нь хамт.
	\item \textit{Барилгачин} класс нь эд ангиудыг цуглуулж, эцсийн объектыг build() аргаар угсардаг.
	% хэд хэдэн аргын дуудлагыг гинжлэх замаар объектыг тохируулах програмчлалын уншигдахуйц байдлыг нэмэгдүүлдэг.
	\item Захиалагч нь байгуулагчийн интерфэйсээр дамжуулан объект байгуулах үйл явцыг удирд -даг. Барилгачин класс нь харин объект үүсгэх ажлыг зохицуулдаг.
\end{itemize}
Объект нь олон хэсэг эсвэл хослолын сонголтуудыг шаарддаг бөгөөд энэ нь олон тооны байгуулагчуудыг хэт ачаалахад хүргэх нөхцөлд энэ үлгэр загварыг ашигладаг. Жишээ нь, олон сонголттой хоол бүхий хоолны иж бүрдлийг хийх, эсвэл нэмэлт талбар бүхий хэрэглэгчийг байгуулах зэрэг орно. Энэ нь өөрчлөгдөшгүй объектууд эсвэл тохиргооны хүнд объектуудыг (жишээ нь, өгөгдлийн сангийн холболтын тохиргоо, нарийн төвөгтэй GUI бүрэлдэхүүн хэсгүүд) бүтээхэд түгээмэл байдаг.\\
\textbf{Давуу тал}: Хэд хэдэн аргын дуудалтыг гинжлэх замаар програмын уншигдахуйц байдлыг нэмэгдүүлдэг. Байгуулагчын бичдэсийг өөрчлөхгүйгээр нэмэлт параметр эсвэл алхамуудыг хялбархан нэмж болно. Барилгачин объект нь өөрөө түр зуурын, өөрчлөгддөг контейнер бөгөөд эцсийн өөрчлөгддөггүй объектыг бүтээх хүртэл бүх тохиргооны мэдээллийг хадгалдаг.\\
\textbf{Сул тал}: Үйл явцыг хянахын тулд нэмэлт класс үүсгэх шаардлагатай бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг.	Бүтээгдэхүүн тус бүрт барилгачин класс хэрэгтэй бөгөөд энэ нь кодын хэмжээг нэмэгдүүлдэг. Энгийн объектуудын хувьд хэт их байж болно.

\subsubsection{Prototype үлгэр загвар}
\quad \quad Энэ үлгэр загвар нь бүтээгдэхүүний заагчийг ашиглан шинэ объект үүсгэх боломжийг олгодог. Энэ нь шинэ объект байгуулахын оронд одоо байгаа объектыг хуулбарлах замаар шинэ объект үүсгэдэг. Ингэхдээ конкрет \textit{прототипийг} хэрэгжүүлдэг ихэвчлэн нэг аргатай clone() интерфейсийг зарладаг. Клиент нь классуудыг шууд үүсгэхийн оронд прототипийг өөрөө хувилахыг асуух замаар шинэ объектуудыг шаарддаг. Гол шинж чанар нь:
\begin{itemize}
	\item Объектыг хувилах ажлыг тухайн объектод томилон илгээдэг.
	\item Кодыг конкрет классуудтай холбохоос зайлсхийдэг учир код нь ганц ерөнхий "prototype" интерфейстэй харьцдаг.
	\item Объект байгуулах нь үнэтэй эсвэл төвөгтэй үед ашигтай байдаг, өөрөөр хэлбэл одоо байгаа прототипийг хуулбарлах нь илүү хялбар байх болно.
\end{itemize}
Ижил төстэй эсвэл эхнээс нь байгуулахад үнэтэй объектуудыг бүтээхэд хэрэгтэй.\\
\textbf{Давуу тал}: Клиент хувилах объектын классыг мэдэх шаардлагагүй ба одоо байгаа прототипүүд -ийг хувилах замаар дахин давтагдах кодыг арилгах боломжтой. Мөн програм ажиллаж байх үед шинэ прототип нэмэхэд хялбар.\\
\textbf{Сул тал}: Тойрог үүсгэн нэг нэгнээ зааж хандсан эсвэл гадаад нөөцөөс хамаарсан нарийн төвөгтэй объектуудыг хувилах нь төвөгтэй эсвэл алдаатай байж болно. Класс бүрт  clone()  аргыг хэрэг -жүүлэх ёстой. Гүн ба гүехэн\footnote{
	Гүехэн хуулах: Объектын дээд түвшний шинж чанаруудыг хуулах боловч эх хувийн аль ч үүрлэсэн объектыг бус түүний заагчийг оноодог. Энэ нь илүү хурдан боловч хуулбар дахь үүрлэсэн өгөгдөлд өөрчлөлт оруулах нь анхны объектод нөлөөлнө гэсэн үг юм.
	Гүн хуулах: Шинэ объект үүсгэж, бүх үүрлэсэн объектуудыг давталттайгаар хуулбарлаж, хуулбар нь эх хувилбараас бүрэн хамааралгүй эсэхийг баталгаажуулна. Энэ нь нарийн төвөгтэй, өөрчлөгддөг өгөгдлийн бүтцэд илүү аюулгүй боловч илүү удаан бөгөөд санах ой их шаарддаг.
} хуулалттай холбоотой асуудлуудыг анхааралтай авч үзэх шаардлагатай.

\subsection{Structural үлгэр загварууд}
Structural үлгэр загварууд нь класс болон объектуудыг уян хатан байлгахын зэрэгцээ том бүтэц болгон хэрхэн бүрдүүлэх талаар авч үздэг.




% Эндээс засварлана
\subsubsection{Adapter үлгэр загвар}
\quad \quad Нэг интерфэйсийг өөр интерфэйс рүү хөрвүүлэх боломжийг олгодог. Энэ нь өөр интерфэйсийг шаарддаг клиентүүдэд зориулж хуучин эсвэл таарахгүй интерфэйс бүхий объектуудыг ашиглах боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Клиент болон үйлчилгээг үзүүлэгчийн хоорондох интерфэйсийн зөрүүг арилгах.
	\item \textit{Адаптер} класс нь үйлчилгээг үзүүлэгчийн интерфэйсийг хэрэгжүүлдэг бөгөөд дараа нь үйлчилгээг үзүүлэгчийн объект руу дуудлага дамжуулдаг.
	\item Клиент нь зөвхөн адаптерийн интерфэйстэй харьцдаг.
\end{itemize}
Хуучин кодыг шинэ систем эсвэл шинэ интерфэйс шаарддаг гуравдагч талын номын сан эсвэл API-тэй нэгтгэхэд ашигладаг. Жишээ нь, Java-ийн InputStreamReader класс нь InputStream (байт урсгал) -ийг Reader (тэмдэгт урсгал) интерфэйс рүү хөрвүүлдэг.\\
\textbf{Давуу тал}: Хуучин кодыг шинэ системд дахин ашиглах боломжийг олгодог. Клиент болон үйлчилгээг үзүүлэгчийн хоорондох хамаарлыг бууруулдаг. Мөн олон үйлчилгээг үзүүлэгчийн интерфэйсийг нэг адаптерээр нэгтгэх боломжийг олгодог.\\
\textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд адаптер нь үйлчилгээг үзүүлэгчийн интерфэйсийг бүрэн дэмжихгүй байж болно.

\subsubsection{Bridge Pattern}
\quad \quad Абстракц болон түүний хэрэгжилтийг тусгаарлах боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Абстракц болон түүний хэрэгжилтийг тусгаарлах.
	\item Абстракц нь хэрэгжилтийн интерфэйсийг агуулдаг бөгөөд дараа нь хэрэгжилтийн объект руу дуудлага дамжуулдаг.
	\item Клиент нь зөвхөн абстракцын интерфэйстэй харьцдаг.
\end{itemize}
Абстракц болон түүний хэрэгжилт нь өөр өөр шалтгаанаар өөрчлөгдөж болзошгүй үед энэ үлгэр загварыг ашигладаг. Жишээ нь, график хэрэглэгчийн интерфэйсийн элементүүдийг (жишээ нь, товчлуур, текст хайрцаг) платформ тус бүрийн хэрэгжилтээс тусгаарлаж болно.\\
\textbf{Давуу тал}: Абстракц болон түүний хэрэгжилтийг тусгаарлах боломжийг олгодог. Абстракц болон хэрэгжилтийн аль алиныг нь бие даан өөрчлөх боломжийг олгодог. Мөн олон хэрэгжилтийн хувилбаруудыг дэмжихэд хялбар.\\
\textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд абстракц нь хэрэгжилтийн интерфэйсийг бүрэн дэмжихгүй байж болно.	

\subsubsection{Composite үлгэр загвар}
\quad \quad Объектуудыг модны бүтэц болгон зохион байгуулж,	 нэгж болон бүрэлдэхүүн хэсгүүдийг ижил байдлаар харьцах боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Композит болон навчны объектууд ижил интерфэйсийг хэрэгжүүлдэг.
	\item Композит объект нь хүүхэд объектуудын цуглуулгыг агуулж, хүүхэд объектууд дээр үйлдлүүдийг гинжин хэлхээнээр гүйцэтгэдэг.
	\item Клиент нь композит болон навчны объектуудыг ижил байдлаар харьцдаг.
\end{itemize}
Ижил төрлийн объектуудын ижил үйлдлийг нэгтгэх шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, график хэрэглэгчийн интерфэйсийн элементүүдийг (жишээ нь, цэс, товчлуур, текст хайрцаг) модны бүтэц болгон зохион байгуулж, хэрэглэгчийн интерфэйсийг ижил байдлаар удирдах боломжийг олгодог.\\	
\textbf{Давуу тал}: Композит болон навчны объектуудыг ижил байдлаар харьцах боломжийг олгодог. Композит бүтэц нь динамикаар өөрчлөгдөж, шинэ хүүхэд объектуудыг нэмэх эсвэл устгах боломжтой. Мөн модны бүтцийн бүх түвшинд үйлдлүүдийг гинжин хэлхээнээр гүйцэтгэх боломжийг олгодог.\\
\textbf{Сул тал}: Композит бүтэц нь төвөгтэй бөгөөд удирдах, ойлгоход хэцүү байж болно. Зарим тохиолдолд навчны объектуудыг композит объектуудаас ялгах нь төвөгтэй байж болно.	

\subsubsection{Decorator үлгэр загвар}
\quad \quad Объектын үйлдлийг динамикаар нэмэх эсвэл өөрчлөх боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлдлийг нэмэх эсвэл өөрчлөхийн тулд объектын оронд түүний оронд \textit{декоратор} объект ашигладаг. 
	\item Декоратор класс нь анхны объектын интерфэйсийг хэрэгжүүлдэг бөгөөд дараа нь анхны объект руу дуудлага дамжуулдаг.
	\item Клиент нь зөвхөн декораторын интерфэйстэй харьцдаг.
\end{itemize}
Хувьсах эсвэл нэмэлт функцтэй объектуудыг динамикаар бий болгох шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн I/O номын сан нь InputStream болон Reader зэрэг анхны объектуудыг янз бүрийн декораторууд (жишээ нь, BufferedInputStream, DataInputStream) ашиглан нэмэлт үйлдлүүдээр (жишээ нь, буферлалт, өгөгдлийн уншилт) чимэглэж болно.\\
\textbf{Давуу тал}: Объектын үйлдлийг динамикаар нэмэх эсвэл өөрчлөх боломжийг олгодог. Анхны класс эсвэл модульыг өөрчлөхгүйгээр шинэ функц нэмэх боломжийг олгодог. Мөн олон декораторуудыг гинжин хэлхээнээр холбож, олон төрлийн функцтэй объектуудыг бий болгох боломжийг олгодог.\\
\textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд декоратор нь анхны объектын интерфэйсийг бүрэн дэмжихгүй байж болно.

\subsubsection{Facade үлгэр загвар}
\quad \quad Нэг буюу хэд хэдэн нарийн төвөгтэй систем, номын сангийн энгийн интерфэйсийг хангадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Нарийн төвөгтэй систем, номын сангийн ард энгийн интерфэйсийг хангадаг.
	\item Фасад класс нь нарийн төвөгтэй системийн олон үйлдлийг нэгтгэж, энгийн аргаар дамжуулдаг.
	\item Клиент нь зөвхөн фасадын интерфэйстэй харьцдаг.
\end{itemize}
Нарийн төвөгтэй систем, номын санг хялбархан ашиглах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн JDBC API нь өгөгдлийн сантай харьцахын тулд фасадын интерфэйсийг хангадаг.\\
\textbf{Давуу тал}: Нарийн төвөгтэй систем, номын санг хялбархан ашиглах боломжийг олгодог	. Клиент болон нарийн төвөгтэй системийн хоорондох хамаарлыг бууруулдаг. Мөн нарийн төвөгтэй системийн олон үйлдлийг нэгтгэж, энгийн аргаар дамжуулдаг.\\	
\textbf{Сул тал}: Фасад нь нарийн төвөгтэй системийн бүх функцэд хандах боломжийг хангахгүй байж болно. Зарим тохиолдолд фасад нь нарийн төвөгтэй системийн интерфэйсийг бүрэн дэмжихгүй байж болно.

\subsubsection{Flyweight үлгэр загвар}
\quad \quad Их хэмжээний объектуудыг үр ашигтайгаар удирдах боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Их хэмжээний объектуудыг хуваалцах замаар санах ойг хэмнэх.
	\item \textit{Flyweight} класс нь хуваалцсан өгөгдөл (жишээ нь, дүрслэл, төлөв) болон хуваалцдаггүй өгөгдөл (жишээ нь, байрлал, төлөв) -ийг агуулдаг.
	\item Клиент нь зөвхөн flyweight-ийн интерфэйстэй харьцдаг.
\end{itemize}
Их хэмжээний ижил төстэй объектуудыг удирдах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, текст засварлагч нь ижил үсэг дүрсүүдийг хуваалцаж, санах ойг хэмнэхийн тулд flyweight үлгэр загварыг ашиглаж болно.\\
\textbf{Давуу тал}: Их хэмжээний объектуудыг үр ашигтайгаар удирдах боломжийг олгодог. Санах ойг хэмнэхийн тулд ижил төстэй объектуудыг хуваалцдаг. Мөн flyweight объектуудыг дахин ашиглах боломжийг олгодог.\\
\textbf{Сул тал}: Flyweight объектуудыг зохицуулахын тулд нэмэлт төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд flyweight нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.	

\subsubsection{Proxy үлгэр загвар}
\quad \quad Бусад объект руу хандах хяналтын цэгийг хангадаг. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтын цэгийг хангадаг.
	\item Прокси класс нь үйлчилгээг үзүүлэгчийн интерфэйсийг хэрэгжүүлдэг бөгөөд дараа нь үйлчилгээг үзүүлэгчийн объект руу дуудлага дамжуулдаг.
	\item Клиент нь зөвхөн проксийн интерфэйстэй харьцдаг.
\end{itemize}
Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтыг хэрэгтэй үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн RMI (Remote Method Invocation) нь алсын объект руу хандах прокси объектуудыг үүсгэдэг.\\
\textbf{Давуу тал}: Үйлчилгээг үзүүлэгчийн объект руу хандах хяналтыг хангадаг. Үйлчилгээг үзүүлэгчийн объектын амьдралын мөчлөгийг удирдах боломжийг олгодог. Мөн үйлчилгээг үзүүлэгчийн объект руу хандах өмнөх боловсруулалт (жишээ нь, кэшлэх, аюулгүй байдал) -ийг гүйцэтгэх боломжийг олгодог.\\
\textbf{Сул тал}: Нэмэлт түвшш буюу төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд прокси нь үйлчилгээг үзүүлэгчийн интерфэйсийг бүрэн дэмжихгүй байж болно.		

\subsection{Behavioral үлгэр загварууд}
Behavioral үлгэр загварууд нь объект хоорондын холбоос, үүргийг тодорхойлох, хяналтын урсгал болон алгоритмыг удирдах талаар тусгасан байдаг.

\subsubsection{Observer үлгэр загвар}
\quad \quad Нэг объектын төлөв өөрчлөгдөхөд хамааралтай объектуудад автоматаар мэдэгдэх боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Нэг объект (subject) нь өөрт хамааралтай олон объектууд (observers) -ыг удирддаг.
	\item Subject объект нь төлөвийн өөрчлөлтийг observers объектуудад мэдэгддэг.
	\item Observers объектууд нь subject объектын төлөвийн өөрчлөлтөд хариу үйлдэл үзүүлдэг.
\end{itemize}
Үйл явдлын хяналт, үйл явдлын хариу үйлдэл, эсвэл тараах системд энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Swing фреймворк нь товчлуур дээр дарах зэрэг үйл явдлуудыг хянахын тулд observer үлгэр загварыг ашигла	даг.\\
\textbf{Давуу тал}: Объект хоорондын сул хамаарлыг хангадаг. Subject болон observers объектуудыг бие даан өөрчлөх боломжийг олгодог. Мөн олон observers объектуудыг нэг subject объекттой холбох боломжийг олгодог.\\
\textbf{Сул тал}: Observers объектуудын тоо их байх үед гүйцэтгэлд нөлөөлж болзошгүй.	

\subsubsection{Strategy үлгэр загвар}	
\quad \quad Нэг алгоритмыг өөр алгоритмтай солих боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Алгоритмыг тусгаарлахын тулд хийсвэр \textit{стратеги} интерфэйсийг тодорхойлдог.
	\item Тус интерфэйсийг хэрэгжүүлдэг олон \textit{конкрет стратеги} классууд байдаг.
	\item Клиент нь стратеги интерфэйсээр дамжуулан алгоритмыг сонгодог.
\end{itemize}
Алгоритмыг сонгох эсвэл өөрчлөх шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Collections.sort() аргыг нь янз бүрийн эрэмбэлэх стратегиудыг (жишээ нь, өсөх, буурах) дэмжихийн тулд стратеги үлгэр загварыг ашигладаг.\\
\textbf{Давуу тал}: Алгоритмыг бие даан өөрчлөх боломжийг олгодог. Клиент нь зөвхөн стратеги интерфэйстэй харьцдаг. Мөн шинэ стратеги классуудыг хялбархан нэмж болно.\\
\textbf{Сул тал}: Нэмэлт төвөгтэй байдлыг нэмж оруулдаг. Зарим тохиолдолд стратеги нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.

\subsubsection	{Command үлгэр загвар}
\quad \quad Үйлдлийг объект болгон төлөөлөх боломжийг олгодог. Гол шинж чанар нь:
\begin{itemize}
	\item Үйлдлийг гүйцэтгэхийн тулд \textit{комманд} объект ашигладаг.
	\item Комманд класс нь үйлдлийг гүй		цэтгэхийн тулд \textit{гүйлгэх} аргыг хэрэгжүүлдэг.
	\item Клиент нь зөвхөн коммандын интерфэйстэй харьцдаг.
\end{itemize}
Командуудыг хадгалах, дараах байдлаар гүйцэтгэх, эсвэл буцаах шаардлагатай үед энэ үлгэр загварыг ашигладаг. Жишээ нь, Java-ийн Swing фреймворк нь товчлуур дээр дарах зэрэг үйлдлүүдийг гүйцэтгэхийн тулд комманд үлгэр загварыг ашигладаг.\\
\textbf{Давуу тал}: Үйлдлийг объект болгон төлөөлөх боломжийг олгодог. Коммандуудыг хадгалах, дараах байдлаар гүйцэтгэх, эсвэл буцаах боломжийг олгодог. Мөн шинэ комманд классуудыг хялбархан нэмж болно.\\
\textbf{Сул тал}: Нэмэлт төвөгтэй байдлыг нэмж о	руулдаг. Зарим тохиолдолд комманд нь бүх шаардлагатай өгөгдлийг агуулж чадахгүй байж болно.	

\subsubsection{Iterator үлгэр загвар}
\section{...}
...