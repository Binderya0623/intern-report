\section{Урвуу инженерчлэл: "Auftragsverwaltung" систем дэх зохиомжийн үлгэр загварууд}
Энэ хэсэгт Жава технологийг ашиглан хэрэгжүүлсэн бараа захиалгийг зохицуулах Герман нэршлийн конвенцтэй "Auftragsverwaltung" систем дээр урвуу инженерчлэлийн аргачлалаар програм хангамжийн зохиомжийн үлгэр загваруудыг уг системд хэрхэн ашигласан байгааг олж тогтооно.

\subsection{Системийн статик загвар}
Системийн классын диаграмыг гаргахын тулд Eclipse IDE дээрх PlantUML\footnote{https://plantuml.com/eclipse} програм хангамжийн багажыг ашигласан. Гэвч энэ багаж нь классууд хоорондын холбоосуудыг, тухайлбал бүрдмэл, нийлмэл зэрэг холбоог оновчтой гаргаж чадаагүй. Юуны түрүүнд энэ системийн нэршлийн конвенц нь Герман хэл дээр хийгдсэн учир тодорхой үгсийн Герман–Англи нэршлийн конвенцийг гаргах шаардлага үүссэн. Жишээ нь, "Auftragsverwaltung" нь "OrderManagement" буюу захиалгын удирдлага, "Auftrag" нь Order" буюу захиалга, "Kunde" нь "Customer" буюу харилцагч, "auftragLoeschen" нь "deleteOrder" буюу Order (Aufrag) классын устгагч гэх мэт. Хавсралт B хэсгээс эдгээр орчуулгыг харж болно.

Холбоосуудын төрлийг тодорхойлохын тулд класс тус бүрийн устгагчийн хэрэгжүүлэлтийг ажигласан. Жишээ нь, Order (Aufrag), OrderItem (Aufragsposition) классуудын хувьд Order классын объектийг устгах үед OrderItem классын объектуудаас бүрдсэн вектороор entfernenPos аргын тусламжтай гүйж устгаж байна. Харин Customer (Kunde) классын объектыг устгалгүй үлдээсэн байна. Иймд Order, OrderItem классууд хоорондоо нийлмэл холбоотой бол Order, Customer классууд хоорондоо бүрдмэл холбоотой гэж дүгнэлээ.
\begin{lstlisting}[language=Java, caption=Order классын устгагч auftragLoeschen, frame=single]
public boolean entfernenPos(Auftragsposition apos)
{
    boolean rc = apositionen.remove(apos);
    if (rc)
        this.aktualisieren();
    return rc;
}

public void auftragLoeschen()
{
    Iterator<Auftragsposition> positionen =
            apositionen.iterator();
    while (positionen.hasNext())
    {
        entfernenPos(positionen.next());
    }
}
\end{lstlisting}

Үүнтэй адилаар "Applicationlogic" багцын бүх классын нэрсийг жагсааж, тэдгээрийн хоорон -дын холбоосуудыг илрүүлсэн. Дараа нь, холбоосуудын төрлийг тодорхойлж, UML классын диаграмыг гаргасан. Үүний үр дүнг \ref{fig:diagram1} зурагт үзүүлэв. Мөн Item (Artikel) класс нь гадаад "Utility" багцаас (зураг \ref{fig:diagram4})\quad Money (Geld) классыг ашиглаж байгаа тул энэ холбоосыг харуу -лаагүй болно.

\begin{figure}
	\centering
	\includegraphics[width=15cm]{images/diagram1.png}
	\caption{"Applicationlogic" багцын классын диаграм}
	\label{fig:diagram1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=10cm]{images/diagram4.png}
	\caption{"Utility" багцын классын диаграм}
	\label{fig:diagram4}
\end{figure}

\subsection{Системийн зохиомж}
Энэ хэсэгт "Auftragsverwaltung" системд илрүүлсэн гол зохиомжийн үлгэр загваруудын зорилго, хэрэглээ, бүтцийн элемент, өмнө тулгарч болох асуудал, үр дүн, жишээ код болон систем доторх бодит хэрэгжүүлэлтийг дэлгэрэнгүй авч үзнэ.

\subsubsection{"Iterator" үлгэр загвар}
Order классын бүх талбар, аргуудаар статик уншлага хийн \verb|apositionen.iterator()|,\\ \verb|while (positionen.hasNext())|,\verb| positionen.next()| мөрүүдийг тэмдэглэж үлгэр загварт заавал байх элементүүд кодод ямар хэлбэрээр илэрсэнг харлаа. Энд apositionen нь \textit{бүрдэл} болж, түүний \verb|iterator()| аргыг дуудаж байгаа нь "Iterator" интерфэйсийг ашиглаж буйг илтгэнэ. \verb|auftragLoeschen()| болон \verb|getAuftragssumme()| мэт аргуудын давталтын логикыг уншиж, хэрхэн давталт явдаг, давталтын үед ямар үйлдэл хийгдэхийг тодруулсан. Давталтын туршид бүрдлүүдтэй хэрхэн харьцаж байгааг анхааран харж, "concurrent modification"\footnote{Конкуррент програмчлалд өгөгдлийн бүтцийг өөр процесс эсвэл тредээр давтаж байх үед өөрчилсөн тохиолдолд "concurrent modification" үүсдэг. Энэ нь үнэн байхаа больсон өгөгдлийн бүтцээр гүйснээс үүдсэн урьдчилан таамаглах боломжгүй өгөгдлийн эвдрэл эсвэл "runtime error" алдааг үүсгэж болно.} зэрэг асуудал үүсэх эрсдлийг тооцсон. Дээрх ажиглалтаас үлгэр загварын шинж тэмдгүүд илэрсэн тул тухайн кодонд "Iterator" үлгэр загвар ашиглагдсан гэж тодорхойлсон. Энд apositionen нь \verb|Vector<Auftragsposition>| бөгөөд давталт хийхдээ \verb|apositionen.iterator()| ашиглагдаж байна. \verb|getAuftragssumme()| нь \verb|while(positionen.hasNext()){...positionen.next()...}| маягаар стандарт давталтыг ашиглан бүх Amount (Betrag) буюу үнийн дүнг олж байна. Энэ нь "Iterator" интерфэйсийн классик хэрэглээ юм.

\begin{lstlisting}[language=Java, caption=Order классын арга getAuftragssumme, frame=single]
  public Geld getAuftragssumme()
  {
    Iterator<Auftragsposition> positionen =
        apositionen.iterator();
    Geld ergebnis = new Geld(0, 0, waehrung);
    if (positionen.hasNext())
      ergebnis = new Geld(positionen.next().getBetrag());
    while (positionen.hasNext())
    {
      ergebnis.addieren(positionen.next().getBetrag());
    }
    return ergebnis;
  }
\end{lstlisting}

\subsubsection{"Singleton" үлгэр загвар}
OrderManagement классын статик талбар дээр шууд \verb|new Auftragsverwaltung()| дуудаж байгаа нь "eager initialization"\footnote{"Eager initialization" нь програмчлалын стратеги бөгөөд объект эсвэл нөөцийг анх ашиглахыг хүсэх хүртэл хүлээх биш, агуулагдсан класс нь ачаалагдсан даруйд үүсгэгддэг.} бөгөөд тредүүдэд аюулгүй байдаг боловч хэзээ ч ашиглагдахгүй объект байгуулагдах эрсдэлтэй. Мөн \verb|DAOFactory.getInstance()| гэх мэт глобал хандалтын цэгүүдийг ажиглалаа.   Класс нь өөрөө "Observer"-ыг хэрэгжүүлж, менежментийн үүрэг гүйцэт- гэж байгаа ч байгуулагчийг private гэж огт заагаагүй тул шинэ Auftragsverwaltung объектыг байгуулж параллел объект үүсгэх эрсдэлтэй. \verb|hinzufuegen()| дотор \verb|auf.addObserver(this)| гэж байгаа нь Singleton объект өөрөө Observable объектын өөрчлөлтийг хүлээн авч DAO-руу өөрчлөлт илгээж байна. Энэ бүх ажиглалтуудаас жинхэнэ "Singleton" үлгэр загварыг ашиглаагүй гэж дүгнэлээ. Харин өөр нэг үлгэр загварыг олсон нь "Observer" юм. Үүнийг дараагийн хэсэгт тайлбарлав.
\begin{lstlisting}[language=Java, caption=OrderManagement классын арга hinzufuegen, frame=single]
  private static Auftragsverwaltung eineAuftragsverwaltung = new Auftragsverwaltung();

  public void hinzufuegen(Auftrag auf)
      throws AuftragException
  {
    int auftragsnr = auf.getAuftragsnr();
    try {
      if (datenquelle.read(auftragsnr) != null)
        throw new AuftragException(
            "Auftrag mit dieser Nummer ist schon vorhanden");
      datenquelle.create(auf.getTO());
      auf.addObserver(this);
    } catch (Exception ex)
    {
      throw new AuftragException("Auftrag " + auftragsnr
          + " konnte nicht gespeichert werden!");
    }
  }
\end{lstlisting}

\subsubsection{"Observer" үлгэр загвар}

OrderManagement классын \verb|hinzufuegen()| арга дотор \verb|auf.addObserver(this)| гэж байгаа нь Singleton объект өөрөө Observable объектын өөрчлөлтийг хүлээн авч DAO-руу өөрчлөлт илгээж байна. Үүнийг ажигласнаар "Observer" үлгэр загвар ашиглагдсан гэж дүгнэлээ. Домай объект болох Customer, Order, OrderItem, Item зэрэг классууд нь Observable-ээс удамшиж, өөрийн төлөв өөрчлөгдөх мөчид \verb|notifyObservers()|-ыг дуудаж бүх бүртгэлтэй Observer-уудад мэдээлж байна. CustomerManagement, OrderManagement, ItemManagement зэрэг класс нь Observer интерфейсийг хэрэгжүүлэн, \verb|update()| аргаар домайн объектоос ирсэн өөрчлөлтийг хүлээн авч байна. Ингэснээр системийн бүх чухал домэйн объектууд үзэгдлийн төв болж, менежер бүр эдгээр үзэгдлийг сонсож, өөрийн цуглуулгад харгалзах домэйн объектыг дахин оруулах/шинэчлэх нь төвлөрсөн удирдлага үүсгэхээс гадна домэйн объект, менежерүү- дийн хооронд нягт уялдаа холбоог бий болгож, нийцэмжтэй байдлыг хадгалж байна.

\subsubsection{"Composite" үлгэр загвар}

% \begin{figure}
% 	\centering
% 	\includegraphics[width=15cm]{images/plantuml.png}
% 	\caption{UML багажаар үүсгэсэн "Applicationlogic" багцын классын диаграм}
% 	\label{fig:hhe}
% \end{figure}

\subsubsection{DAO (Data Access Object) үлгэр загвар}
Intent: Бизнес логик болон өгөгдлийн сан (database) хоорондох харилцааг салгаж, өгөгдлийн хандалтын кодыг төвлөрүүлдэг. Ингэснээр өгөгдлийн сангийн төрөл, схем өөрчлөгдөхөд бусад давхаргаас хамааралгүйгээр шинэчлэлт хийх боломжтой.
Applicability:
Өгөгдлийн сан, файлын систем, REST үйлчилгээ болон бусад I/O үйлдлүүдтэй тухайн давхаргын кодыг багцлах шаардлагатай үед.
Олон бизнес обьект өгөгдлийн үйлдэл хийх үед давталт, дубликацыг багасгах шаардлагатай бол.
Participants:
DAO Interface: SqlDAO<T> — нийтлэг өгөгдөл унших, бичих аргатай.
Concrete DAO: ArtikelDAO, KundeDAO, AuftragDAO — хүссэн хүснэгтийн өргөтгөл.
Model: Artikel, Kunde, Auftrag классууд.
Collaboration:
Business логик DAO interface-ээр дамжин өгөгдөл авах/хадгална.
Concrete DAO-ууд өгөгдлийн сангийн SQL query-үүдийг гүйцэтгэнэ.
Consequences:
Давхаргын тусгаарлалт сайжирна.
Тестлэхэд mock DAO ашиглах замаар өгөгдлийн сангүйгээр unit тест бичиж болно.
Өгөгдлийн сангийн холболт өөрчлөгдөхөд DAO давхаргыг л шинэчлэхэд хангалттай.
Жишээ код:

\begin{lstlisting}
\end{lstlisting}